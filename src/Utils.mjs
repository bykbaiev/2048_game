// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Tile from "./Tile.mjs";
import * as Curry from "../node_modules/rescript/lib/es6/curry.js";
import * as State from "./State.mjs";
import * as Js_dict from "../node_modules/rescript/lib/es6/js_dict.js";
import * as Belt_List from "../node_modules/rescript/lib/es6/belt_List.js";
import * as Belt_Option from "../node_modules/rescript/lib/es6/belt_Option.js";

function getCls(styles, name) {
  return Belt_Option.getWithDefault(Belt_Option.flatMap(Js_dict.get(styles, "default"), (function (defaults) {
                    return Js_dict.get(defaults, name);
                  })), "");
}

function keyCodeToDirection(code) {
  switch (code) {
    case 37 :
        return /* Left */3;
    case 38 :
        return /* Up */0;
    case 39 :
        return /* Right */1;
    case 40 :
        return /* Down */2;
    default:
      return ;
  }
}

function transpose(tiles) {
  return Belt_List.map(tiles, (function (tile) {
                return Curry._2(Tile.GameTile.Setters.y, Curry._2(Tile.GameTile.Setters.x, tile, Curry._1(Tile.GameTile.Getters.y, tile)), Curry._1(Tile.GameTile.Getters.x, tile));
              }));
}

function reverseRow(tiles, size) {
  return Belt_List.map(tiles, (function (tile) {
                return Curry._2(Tile.GameTile.Setters.x, tile, (size - 1 | 0) - Curry._1(Tile.GameTile.Getters.x, tile) | 0);
              }));
}

function rotateClockwise(tiles, size) {
  return reverseRow(transpose(tiles), size);
}

function rotateAntiClockwise(tiles, size) {
  return transpose(reverseRow(tiles, size));
}

function isMoveToRightPossible(tiles, size) {
  return Belt_List.some(tiles, (function (tile) {
                var neighbour = Belt_List.getBy(tiles, (function (t) {
                        if (Curry._1(Tile.GameTile.Getters.y, t) === Curry._1(Tile.GameTile.Getters.y, tile)) {
                          return Curry._1(Tile.GameTile.Getters.x, t) === (Curry._1(Tile.GameTile.Getters.x, tile) + 1 | 0);
                        } else {
                          return false;
                        }
                      }));
                if (Curry._1(Tile.GameTile.Getters.x, tile) < (size - 1 | 0)) {
                  return Belt_Option.mapWithDefault(neighbour, true, (function (t) {
                                return Curry._1(Tile.GameTile.Getters.val, t) === Curry._1(Tile.GameTile.Getters.val, tile);
                              }));
                } else {
                  return false;
                }
              }));
}

function rotateToMoveToRight(size, dir, tiles) {
  switch (dir) {
    case /* Up */0 :
        return reverseRow(transpose(tiles), size);
    case /* Right */1 :
        return tiles;
    case /* Down */2 :
        return transpose(reverseRow(tiles, size));
    case /* Left */3 :
        var tiles$1 = reverseRow(transpose(tiles), size);
        return reverseRow(transpose(tiles$1), size);
    
  }
}

function rotateBack(size, dir, tiles) {
  switch (dir) {
    case /* Up */0 :
        return transpose(reverseRow(tiles, size));
    case /* Right */1 :
        return tiles;
    case /* Down */2 :
        return reverseRow(transpose(tiles), size);
    case /* Left */3 :
        var tiles$1 = reverseRow(transpose(tiles), size);
        return reverseRow(transpose(tiles$1), size);
    
  }
}

function isMovePossible(tiles, size, dir) {
  return isMoveToRightPossible(rotateToMoveToRight(size, dir, tiles), size);
}

function isWin(tiles) {
  return Belt_List.some(tiles, Tile.GameTile.isWinningValue);
}

function isLoss(size, tiles) {
  if (Math.imul(size, size) === Belt_List.size(tiles) && !Belt_List.some(tiles, Tile.GameTile.isWinningValue) && !isMovePossible(tiles, size, /* Up */0) && !isMovePossible(tiles, size, /* Right */1) && !isMovePossible(tiles, size, /* Down */2)) {
    return !isMovePossible(tiles, size, /* Left */3);
  } else {
    return false;
  }
}

function sortTilesByColumn(tiles) {
  return Belt_List.sort(tiles, (function (a, b) {
                if (Curry._1(Tile.GameTile.Getters.y, a) === Curry._1(Tile.GameTile.Getters.y, b)) {
                  return Curry._1(Tile.GameTile.Getters.x, a) - Curry._1(Tile.GameTile.Getters.x, b) | 0;
                } else {
                  return Curry._1(Tile.GameTile.Getters.y, a) - Curry._1(Tile.GameTile.Getters.y, b) | 0;
                }
              }));
}

function movementReducer(ts, tile) {
  var addTile = function (x) {
    return Belt_List.add(ts, Curry._1(Tile.GameTile.Converters.toAverage, Curry._2(Tile.GameTile.Setters.x, tile, x)));
  };
  return Belt_Option.mapWithDefault(Belt_List.head(ts), addTile(0), (function (t) {
                if (Curry._1(Tile.GameTile.Getters.y, t) === Curry._1(Tile.GameTile.Getters.y, tile)) {
                  if (Curry._1(Tile.GameTile.Getters.val, t) === Curry._1(Tile.GameTile.Getters.val, tile) && !Curry._1(Tile.GameTile.Getters.merged, t)) {
                    return Belt_List.add(Belt_Option.getWithDefault(Belt_List.drop(ts, 1), /* [] */0), Curry._1(Tile.GameTile.Converters.toMerged, Curry._2(Tile.GameTile.Setters.val, Curry._2(Tile.GameTile.Setters.id, t, Curry._1(Tile.GameTile.Getters.x, tile) > Curry._1(Tile.GameTile.Getters.x, t) ? Curry._1(Tile.GameTile.Getters.id, tile) : Curry._1(Tile.GameTile.Getters.id, t)), (Curry._1(Tile.GameTile.Getters.val, t) << 1))));
                  } else {
                    return addTile(Curry._1(Tile.GameTile.Getters.x, t) + 1 | 0);
                  }
                } else {
                  return addTile(0);
                }
              }));
}

function moveRight(size, tiles) {
  return reverseRow(Belt_List.reduce(sortTilesByColumn(reverseRow(tiles, size)), /* [] */0, movementReducer), size);
}

function move(dir, state) {
  var internals = State.getInternals(state);
  var tiles = internals.tiles;
  var rotated = rotateToMoveToRight(4, dir, tiles);
  if (!(!State.isWin(state) && !State.isLoss(state) && isMoveToRightPossible(rotated, 4))) {
    return state;
  }
  var moved = moveRight(4, rotated);
  var movedInternals = State.setTiles(internals, rotateBack(4, dir, moved));
  if (Belt_List.some(moved, Tile.GameTile.isWinningValue) && !State.isPlayingAfterWin(state)) {
    return {
            TAG: /* Win */1,
            _0: movedInternals
          };
  }
  if (isLoss(4, moved)) {
    return {
            TAG: /* Loss */2,
            _0: movedInternals
          };
  }
  var updated = Belt_List.add(moved, Tile.GameTile.createNewTile(moved));
  var updatedInternals = State.setTiles(internals, rotateBack(4, dir, updated));
  if (State.isPlayingAfterWin(state)) {
    return {
            TAG: /* PlayingAfterWin */3,
            _0: updatedInternals
          };
  } else if (Belt_List.some(updated, Tile.GameTile.isWinningValue)) {
    return {
            TAG: /* Win */1,
            _0: updatedInternals
          };
  } else if (isLoss(4, updated)) {
    return {
            TAG: /* Loss */2,
            _0: updatedInternals
          };
  } else {
    return {
            TAG: /* Playing */0,
            _0: updatedInternals
          };
  }
}

var gridSize = 4;

export {
  gridSize ,
  getCls ,
  keyCodeToDirection ,
  transpose ,
  reverseRow ,
  rotateClockwise ,
  rotateAntiClockwise ,
  isMoveToRightPossible ,
  rotateToMoveToRight ,
  rotateBack ,
  isMovePossible ,
  isWin ,
  isLoss ,
  sortTilesByColumn ,
  movementReducer ,
  moveRight ,
  move ,
  
}
/* State Not a pure module */
