// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_dict from "../node_modules/rescript/lib/es6/js_dict.js";
import * as Js_math from "../node_modules/rescript/lib/es6/js_math.js";
import * as Belt_List from "../node_modules/rescript/lib/es6/belt_List.js";
import * as Caml_int32 from "../node_modules/rescript/lib/es6/caml_int32.js";
import * as Belt_Option from "../node_modules/rescript/lib/es6/belt_Option.js";

function getCls(styles, name) {
  return Belt_Option.getWithDefault(Belt_Option.flatMap(Js_dict.get(styles, "default"), (function (defaults) {
                    return Js_dict.get(defaults, name);
                  })), "");
}

function tilesToBoard(size, tiles) {
  return Belt_List.makeBy(size, (function (y) {
                return Belt_List.makeBy(size, (function (x) {
                              return Belt_Option.map(Belt_List.getBy(tiles, (function (tile) {
                                                if (tile.pos.x === x) {
                                                  return tile.pos.y === y;
                                                } else {
                                                  return false;
                                                }
                                              })), (function (tile) {
                                            return tile.val;
                                          }));
                            }));
              }));
}

function createTile(val, x, y) {
  return {
          val: val,
          pos: {
            x: x,
            y: y
          }
        };
}

function getPair(max, idx) {
  if (idx >= Math.imul(max, max)) {
    return ;
  }
  var y = Caml_int32.mod_(idx, max);
  return [
          Caml_int32.div(idx, max),
          y
        ];
}

function positionFilterPred(tiles, position) {
  var x = position[0];
  if (x === -1 && position[1] === -1) {
    return false;
  }
  var y = position[1];
  return !Belt_List.some(tiles, (function (param) {
                var pos = param.pos;
                if (pos.x === x) {
                  return pos.y === y;
                } else {
                  return false;
                }
              }));
}

function createNewTile(tiles) {
  var allPositions = Belt_List.makeBy(16, (function (param) {
          return getPair(4, param);
        }));
  var availablePositions = Belt_List.keep(Belt_List.map(allPositions, (function (pos) {
              return Belt_Option.getWithDefault(pos, [
                          -1,
                          -1
                        ]);
            })), (function (param) {
          return positionFilterPred(tiles, param);
        }));
  var idx = Js_math.random_int(0, Belt_List.size(availablePositions));
  var match = Belt_Option.getWithDefault(Belt_List.get(availablePositions, idx), [
        0,
        0
      ]);
  var randTileIndicator = Js_math.random_int(0, 4);
  return createTile(randTileIndicator === 3 ? 4 : 2, match[0], match[1]);
}

function keyCodeToDirection(code) {
  switch (code) {
    case 37 :
        return /* Left */3;
    case 38 :
        return /* Up */0;
    case 39 :
        return /* Right */1;
    case 40 :
        return /* Down */2;
    default:
      return ;
  }
}

function isWinningValue(tile) {
  return tile.val === 2048;
}

function transpose(tiles) {
  return Belt_List.map(tiles, (function (tile) {
                return {
                        val: tile.val,
                        pos: {
                          x: tile.pos.y,
                          y: tile.pos.x
                        }
                      };
              }));
}

function reverseRow(tiles, size) {
  return Belt_List.map(tiles, (function (tile) {
                return {
                        val: tile.val,
                        pos: {
                          x: (size - 1 | 0) - tile.pos.x | 0,
                          y: tile.pos.y
                        }
                      };
              }));
}

function rotateClockwise(tiles, size) {
  return reverseRow(transpose(tiles), size);
}

function rotateAntiClockwise(tiles, size) {
  return transpose(reverseRow(tiles, size));
}

function isMoveToRightPossible(tiles, size) {
  return Belt_List.some(tiles, (function (tile) {
                var neighbour = Belt_List.getBy(tiles, (function (t) {
                        if (t.pos.y === tile.pos.y) {
                          return t.pos.x === (tile.pos.x + 1 | 0);
                        } else {
                          return false;
                        }
                      }));
                if (tile.pos.x < (size - 1 | 0)) {
                  return Belt_Option.mapWithDefault(neighbour, true, (function (t) {
                                return t.val === tile.val;
                              }));
                } else {
                  return false;
                }
              }));
}

function rotateToMoveToRight(size, dir, tiles) {
  switch (dir) {
    case /* Up */0 :
        return reverseRow(transpose(tiles), size);
    case /* Right */1 :
        return tiles;
    case /* Down */2 :
        return transpose(reverseRow(tiles, size));
    case /* Left */3 :
        var tiles$1 = reverseRow(transpose(tiles), size);
        return reverseRow(transpose(tiles$1), size);
    
  }
}

function rotateBack(size, dir, tiles) {
  switch (dir) {
    case /* Up */0 :
        return transpose(reverseRow(tiles, size));
    case /* Right */1 :
        return tiles;
    case /* Down */2 :
        return reverseRow(transpose(tiles), size);
    case /* Left */3 :
        var tiles$1 = reverseRow(transpose(tiles), size);
        return reverseRow(transpose(tiles$1), size);
    
  }
}

function isMovePossible(tiles, size, dir) {
  return isMoveToRightPossible(rotateToMoveToRight(size, dir, tiles), size);
}

function isWin(tiles) {
  return Belt_List.some(tiles, isWinningValue);
}

function isLoss(size, tiles) {
  if (Math.imul(size, size) === Belt_List.size(tiles) && !Belt_List.some(tiles, isWinningValue) && !isMovePossible(tiles, size, /* Up */0) && !isMovePossible(tiles, size, /* Right */1) && !isMovePossible(tiles, size, /* Down */2)) {
    return !isMovePossible(tiles, size, /* Left */3);
  } else {
    return false;
  }
}

function sortTilesByColumn(tiles) {
  return Belt_List.sort(tiles, (function (a, b) {
                if (a.pos.y === b.pos.y) {
                  return a.pos.x - b.pos.x | 0;
                } else {
                  return a.pos.y - b.pos.y | 0;
                }
              }));
}

function setColumn(tile, x) {
  return {
          val: tile.val,
          pos: {
            x: x,
            y: tile.pos.y
          }
        };
}

function setCollapsed(tile, collapsed) {
  return {
          val: tile.val,
          pos: tile.pos,
          collapsed: collapsed
        };
}

function collapsedTileToTile(tile) {
  return {
          val: tile.val,
          pos: tile.pos
        };
}

function movementReducer(ts, tile) {
  var addTile = function (x, collapsed) {
    return Belt_List.add(ts, setCollapsed(setColumn(tile, x), collapsed));
  };
  return Belt_Option.mapWithDefault(Belt_List.head(ts), addTile(0, false), (function (t) {
                if (t.pos.y === tile.pos.y) {
                  if (t.val === tile.val && !t.collapsed) {
                    return Belt_List.add(Belt_Option.getWithDefault(Belt_List.drop(ts, 1), /* [] */0), {
                                val: (t.val << 1),
                                pos: t.pos,
                                collapsed: true
                              });
                  } else {
                    return addTile(t.pos.x + 1 | 0, false);
                  }
                } else {
                  return addTile(0, false);
                }
              }));
}

function moveRight(size, tiles) {
  return reverseRow(Belt_List.map(Belt_List.reduce(sortTilesByColumn(reverseRow(tiles, size)), /* [] */0, movementReducer), collapsedTileToTile), size);
}

function move(dir, tiles) {
  var rotated = rotateToMoveToRight(4, dir, tiles);
  if (!isMoveToRightPossible(rotated, 4)) {
    return tiles;
  }
  var moved = moveRight(4, rotated);
  if (Belt_List.some(moved, isWinningValue) || isLoss(4, moved)) {
    return rotateBack(4, dir, moved);
  }
  var updated = Belt_List.add(moved, createNewTile(moved));
  Belt_List.some(updated, isWinningValue) || isLoss(4, updated);
  return rotateBack(4, dir, updated);
}

var gridSize = 4;

var winningValue = 2048;

export {
  gridSize ,
  winningValue ,
  getCls ,
  tilesToBoard ,
  createTile ,
  getPair ,
  positionFilterPred ,
  createNewTile ,
  keyCodeToDirection ,
  isWinningValue ,
  transpose ,
  reverseRow ,
  rotateClockwise ,
  rotateAntiClockwise ,
  isMoveToRightPossible ,
  rotateToMoveToRight ,
  rotateBack ,
  isMovePossible ,
  isWin ,
  isLoss ,
  sortTilesByColumn ,
  setColumn ,
  setCollapsed ,
  collapsedTileToTile ,
  movementReducer ,
  moveRight ,
  move ,
  
}
/* No side effect */
